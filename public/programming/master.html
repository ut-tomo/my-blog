<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="3iZ0PCFwbOdy1LWlHA3A9nYmzBIZp8Qv12Dw2jHYOEU" />
  <meta name="google-site-verification" content="XvlwfBHUtq90lfXKNDOILZLjLaf1W9QVEWswyW0iwco" />
  <title>Master Theoremとかいうかっこいい定理 - ブログを書いてモチベを上げよう</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>ブログを書いてモチベを上げよう</h1>
  </header>
  
  <div class="page-layout">
  <main class="main-content">
    <div class="breadcrumb">
      <a href="/">ホーム</a> > <a href="/programming">機械学習のお勉強</a> > Master Theoremとかいうかっこいい定理
    </div>
    
    <article>
      <h1>Master Theoremとかいうかっこいい定理</h1>
      <p> 2025年6月20日</p>
      
      <h2>概要</h2>
      <p>
        マスター法という定理の知識がどうやら必要になったので、自分で使いこなせる状態を目指してとりあえずまとめてみようと思います。
        どうやらマスター法の説明をしている日本語の文献はあんまりないようで(そんなに調べたわけではないのですが)とりあえず
        手元のアルゴリズムイントロダクションを基本的に参照してまとめていきます。
      </p>
      <h2>マスター定理の主張</h2>
      <p>\( n \in \mathbb{N}, \)上で以下のように定義される漸化式について考える。</p>
        <p>
            \[
            T(n) = aT\left(\frac{n}{b}\right) + f(n)
            \]
            ただし、\( a \geq 0, b > 1, f(n) \)は十分に大きい全ての実数上で定義されている非負の駆動関数(これについては後で書きます)とする。
            この時\( T(n) \)の漸近的な挙動は以下のように分類される。
            <ol class="content-list">
                <li>
                    <p>\(if \quad f(n) = O(n^{\log_ba-\epsilon}) \quad for \, all \quad \epsilon > 0 \implies T(n) = \Theta(n^{\log_ba})\)</p>
                </li>
                <li>
                    <p>\(if \quad f(n) = \Theta(n^{\log_balg^kn}) \quad for \, some \quad k \geq 0 \implies T(n) = \Theta(n^{\log_ba}lg^{k+1}n)\)</p>
                </li>
                <li>
                    <p>\(if \quad f(n) = \Omega(n^{\log_ba+\epsilon}) \quad for \, some \quad \epsilon > 0 \quad \)<br>
                        \(and \quad af\left(\frac{n}{b}\right) \leq cf(n) \quad for \, some \quad c < 1,\implies T(n) = \Theta(f(n)) \)
                    </p>
            </ol>
        </p>
        <p>
            これだけみるとうーんと唸るしかないですよね。ちなみに明記していませんでしたが\(n\)は基本的に十分に大きな数
            について考えています。小さいnについて考えても計算量の見積もりとなるとあまり意味がないので。
        </p>

        <h2>漸近記法</h2>
        <p>
        上で登場した\( O, \Theta, \Omega \)は漸近記法と呼ばれるもので、計算量の見積もりに使われるものですが、正直ビッグオー記法以外は僕は馴染みがなかったので
        \( \Theta, \Omega \)について触れておきたいです。</p>
        <div style="margin: 20px;"></div>
        <h3>\(\Omega\)記法</h3>
        <p>
            \[
            f(n) \in \Omega(g(n)) \Leftrightarrow \exists c > 0, n_0 \in \mathbb{N} \quad s.t. \quad f(n) \geq cg(n) \geq 0 \quad for \, all \quad n \geq n_0
            \]
        </p>
        <h3>\(\Theta \)記法</h3>
        <p>
            \[
            f(n) \in \Theta(g(n)) \Leftrightarrow \exists c_1, c_2 > 0, n_0 \in \mathbb{N} \quad s.t. \quad c_1g(n) \leq f(n) \leq c_2g(n) \quad for \, all \quad n \geq n_0
            \]
        </p>
        <p>
            ビッグオー記法は計算量の見積もりによくみる記法で、漸近的上界を与えるものです。つまり、
            十分に大きな\( n \)に対して、\( f(n) \)は\( g(n) \)の定数倍以下であることを示します。
            一方で、\(\Omega\)記法は漸近的下界を与えるもので、十分に大きな\( n \)に対して、\( f(n) \)は\( g(n) \)の定数倍以上であることを示します。
            \(\Theta\)記法は、アルゴリズムイントロダクションでは漸近的に"タイトな"限界のために用いると書かれています。
            つまりは、十分に大きな\( n \)に対して、\( f(n) \)は\( g(n) \)の定数倍以上かつ以下であることを示しており、
            任意に2つの関数\(f(n)\)と\(g(n)\)を選んだ際に\(f(n) = \Theta(g(n))\)である必要十分条件は
            \(f(n) = O(g(n))\)かつ\(f(n) = \Omega(g(n))\)であることになります。
        </p>
        <p>
            これらの記法がわかると、なんとなくマスター定理の主張せんとするところが見えてきます。
            最終的には漸化式に対して漸近解を与えたいというのがMaster定理な訳ですが、なんらかの場合分けの基準があって、
            漸近的な挙動を分類しているということぐらいはこの時点で読み取れる気がします。
            
        </p>
        <h2>まずはもう一度漸化式をよくみる</h2>
        <p>
            さて、マスター定理の漸化式をもう一度よく見てみましょう。
            \[
            T(n) = aT\left(\frac{n}{b}\right) + f(n)
            \]
            この式をが見積もろうとしているものは、サイズ\(n\)の問題をサイズ\(n/b\)を持つ\(a\)個のサブ問題
            に分割することによるアルゴリズムの計算コストです。つまりこのアルゴリズムは
            \(a\)個の部分問題をそれぞれ\(T(n/b)\)の時間で再帰的に解くものであり、
            \(f(n)\)は再帰の外で発生する計算時間、つまり問題の分割や結合に要するコストを表しているものとなります。
            そして、部分問題を解くのにかかるコストと再帰以外のコストを天秤にかけて、
            支配的な方のコストが全体の計算コストを決めるというのが基本的なアイデアです。
            ちなみに、\(f(n)\)が駆動関数と呼ばれるのはこの部分がアルゴリズム全体のコストを決めうるから、ということだそうですが、
            それなら両方ともそうじゃないか。
        </p>
        <h2>主張の気持ちだけでも理解する</h2>
        <p>
            マスター定理では、駆動関数が\(n^{\log_ba}\)より支配的か否かによる場合わけがまずなされています。
            ちなみにこの\(n^{\log_ba}\)は分水界関数と呼ぶようです。こいつがまずどこから来たのかを考えたいですね。
        </p>
        <p>
            まず、再帰呼び出し1回あたり\(a\)個の部分問題が生成され、それぞれのサイズは再帰呼び出しが\(i\)回目の時は
            \(\frac{n}{b^i}\)となります。この時再帰呼び出しは問題サイズが定数になるまで続くと考えれば
            再帰の深さは\(\approx \log_b n\)となります。
        </p>
        <p>
            つまり再帰的に呼び出すことによるノード数は
            \[
            \sum_{i=0}^{\log_b n} a^i \approx \frac{a^{\log_b n} - 1}{a - 1} \approx a^{\log_bn}
            \]
            \[
            a^{\log_bn} = e^{\log a \frac{\log n}{\log b}} = n^{\log_b a}
            \]
        </p>
        <p>
            となります。ノード数と書いたのは、再帰的に呼び出すことにより1つの親ノードから\(a\)個の子ノードが生成されるような
            木構造を想像するとわかりやすいと思ったからです。というわけで局所的な処理を一切考えなければ再帰的な
            呼び出しによる計算コストは\(n^{\log_b a}\)となることがわかり、分水界関数と呼んでいるものが得られたことになります。
            これくらいのことがわかればマスター方を覚えることくらいはできそうなので、問題を解く時に使えと言われればできそうではありますが、
            流石にまだモヤモヤする部分が残り過ぎているのでもう少し丁寧にそれぞれのケースについて考えます。
        </p>
        <h2>Case 1</h2>
    </article>
  </main>
  
  <aside class="sidebar">
    <h3>カテゴリ</h3>
    <ul>
      <li><a href="/papers" >論文記録</a></li>
      <li><a href="/ML">機械学習のお勉強</a></li>
      <li><a href="/programming" class="active">その他プログラミング / 情報科学</a></li>
      <li><a href="/bio\logy">その他生物学関連</a></li>
    </ul>
  </aside>
</div>

<button class="mobile-menu-btn" onclick="toggleSidebar()">
  <span>☰</span>
</button>

<div class="sidebar-overlay" onclick="closeSidebar()"></div>
  
  <footer>
    <p>&copy; 2025 ブログを書いてモチベを上げよう. All rights reserved.</p>
  </footer>

  <script>
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.toggle('active');
  overlay.classList.toggle('active');
}

function closeSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.remove('active');
  overlay.classList.remove('active');
}
function copyCode(button) {
  const codeBlock = button.closest('.code-block');
  const codeContent = codeBlock.querySelector('.code-content code');
  const text = codeContent.textContent;
  
  navigator.clipboard.writeText(text).then(() => {
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('コピーに失敗しました:', err);
    // フォールバック: 古いブラウザ対応
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  });
}
</script>
</body>
</html>
