<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="3iZ0PCFwbOdy1LWlHA3A9nYmzBIZp8Qv12Dw2jHYOEU" />
  <meta name="google-site-verification" content="XvlwfBHUtq90lfXKNDOILZLjLaf1W9QVEWswyW0iwco" />
  <title>グラフの表現方法を復習する - utcsBlog 勉強したことをまとめていくブログ</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>utcsBlog 勉強したことをまとめていくブログ</h1>
  </header>
  
  <div class="page-layout">
  <main class="main-content">
    <div class="breadcrumb">
      <a href="/">ホーム</a> > <a href="/programming">その他プログラミング/ 情報科学</a> > グラフの表現方法を復習する
    </div>
    
    <article>
      <h1>グラフの表現方法を復習する</h1>
      <p> 2025年7月4日</p>
      <h2>概要</h2>
      <p>
        僕はずっと名前のイメージから勝手に接続行列=隣接行列だと思っていたのですが(そうだとしているものも見受けられますが)
        どうやら一般的にはIncidence Matrixなるものを接続行列と呼ぶことが多いようですね。
        英語の表現を日本語に直した時に名前がよくわからん感じの名前になってしまうことはよくあることだと思うので
        名前に混乱させられることは受け入れなければいけないとは思うのですがどうも試験なんかがあるならしっかり区別しないといけない
        と思い基礎的なところからしっかり復習していきたいです。
      </p>
      
      <h2>隣接リストの集合による表現 vs 隣接行列表現</h2>
      <p>
        この二つが標準的なグラフの表現方法ということのようです。隣接リストは
        各頂点に対して隣接する頂点のリストを持つというもので、
        隣接行列は頂点の数をnとしたきn\(\times\)nの行列で、行i列jの要素が1ならば
        頂点iと頂点jが隣接していることを表すものです。
        隣接リスト表現はグラフが疎である=\(|E| \ll |V|^2\)という時には
        メモリ効率が良いため重宝されるもののある辺がグラフに属するかという問い合わせをするのに
        最悪O(|V|)の時間がかかるという欠点があり、隣接行列表現はメモリが
        O(|V|^2)と大きくなるものの、グラフが小さい時や特に重み付きでない時などは
        行列要素をそれぞれ1bitで表せるのでその単純さから採用されるケースも多いよう。
      </p>
      <h2>接続行列</h2>
      <p>
        アルゴリズムイントロダクションにて以下のような問題があったので。
      </p>
      <h3>
        問題: 
      </h3>
      <p>
        自己ループを含まない有向グラフ\(G=(V, E)\)の接続行列(Incidence Matrix)は、
        <div class="math-scroll">
          \[
          b_{ij} = \begin{cases}
          1 & \text{辺}j\text{が頂点}i\text{から出ていく時} \\
          -1 & \text{辺}j\text{が頂点}i\text{にはいる時} \\
          0 & \text{その他}
          \end{cases}
          \]
        </div>
      </p>
    </article>
  </main>
  
  <aside class="sidebar">
    <h3>カテゴリ</h3>
    <ul>
      <li><a href="/papers" >論文記録</a></li>
      <li><a href="/ML">機械学習のお勉強</a></li>
      <li><a href="/programming"class="active">その他プログラミング / 情報科学</a></li>
      <li><a href="/biology">その他生物学関連</a></li>
    </ul>
  </aside>
</div>

<button class="mobile-menu-btn" onclick="toggleSidebar()">
  <span>☰</span>
</button>

<div class="sidebar-overlay" onclick="closeSidebar()"></div>
  
  <footer>
    <p>&copy; 2025 utcsBlog 勉強したことをまとめていくブログ. All rights reserved.</p>
  </footer>

  <script>
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.toggle('active');
  overlay.classList.toggle('active');
}

function closeSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.remove('active');
  overlay.classList.remove('active');
}
function copyCode(button) {
  const codeBlock = button.closest('.code-block');
  const codeContent = codeBlock.querySelector('.code-content code');
  const text = codeContent.textContent;
  
  navigator.clipboard.writeText(text).then(() => {
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('コピーに失敗しました:', err);
    // フォールバック: 古いブラウザ対応
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  });
}
</script>
</body>
</html>
