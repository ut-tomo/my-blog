<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="3iZ0PCFwbOdy1LWlHA3A9nYmzBIZp8Qv12Dw2jHYOEU" />
  <title>Chat GPTのすごいところ / Chat GPTって昔は忘れっぽかったよね - ブログを書いてモチベを上げよう</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>ブログを書いてモチベを上げよう</h1>
  </header>
  
  <div class="page-layout">
  <main class="main-content">
    <div class="breadcrumb">
      <a href="/">ホーム</a> > <a href="/ML">機械学習のお勉強</a> > Chat GPTのすごいところ / Chat GPTって昔は忘れっぽかったよね
    </div>
    
    <article>
      <h1>Chat GPTのすごいところ / Chat GPTって昔は忘れっぽかったよね</h1>
      <p> 2025年6月19日</p>
      
      <h2>概要</h2>
      <p>
        この記事はお勉強というよりつぶやきです。<a href="/papers/transformer2.html">Transformerの仕組み</a>を書いていてついでに書きたくなったことです。
        Transformerの仕組みで書いたことを前提に書いてしまうと思います。
      </p>
      <h2>Chat GPTのすごいところ</h2>
        <p>
            GPT系のすごいところは、前の記事でも書いたように"文法的な規則"や"論理的な規則"の明示的な学習を行なっていないにもかかわらず、
            もっともらしい文章、コードなどを生成できるところにあると思っています。このルールを学習していない、という弱点は
            GPT系の初期の頃によく見られた、すごい簡単な計算を間違えたり、9.11と9.9の大きさを比べろというと9.11の方が大きいと答えたりという
            ところに顕著に現れていたと思います。しかしこのようなことは最近はあまり見られないし、コーディングなんかも
            色々なコーディング特化型のAIが出てきたりしていますがすごい長いコードをノーエラーで吐いたりすることを見ると、
            ほんとにプログラミング言語の文法を学習していないのかと疑いたくなりますね。コーディングはもしかしたら、特に
            ウェブエンジニアリングの分野なんかでは定型的な"表現"が多く、それこそ学習しやすいのかもしれませんが。
        </p>
        <h2>Chat GPTって昔は忘れっぽかったよね</h2>
        <p>
            昔のChat GPTって、さっき言ったやんけ!みたいな指示を平気で無視してきたりしていませんでしたか?あまりに人間みたいな答え方をするので
            ちょっと前のことを忘れられたりしてしまうとなんやねんこいつと思ってしまうところですが、それはTransformerの仕組みの中の
            "コンテキストウィンドウ"と呼ばれる部分の長さに起因しています。まずはChat GPTは前の記事で触れたように
            Decoderモデルがベースとなっていて次の単語を予測するように学習されているという仕組みを思い出してください。
            少し蛇足ですが、次の単語を予測する、というのは一番確率が高い単語を出力し続けるわけではなく、次に来得る単語の確率分布を計算して、
            上位の何単語かを保持し続けるイメージのようです。
            ちなみにここでの入力はユーザのプロンプトであり、出力がそれに対する返答っぽくなるのは「そうなるように学習されているから」です。
            そして次の単語(t番目としましょう)を予測するためには翻訳タスクの時と同様にt-1番目までの単語を参照するわけですが、
            その参照できる長さ(t-nのnの大きさ)がコンテキストウィンドウと呼ばれるものです。初期の頃はおそらく
            この行列計算が比較的ナイーブに行われていたことなどに起因してそこまで長いコンテキストウィンドウを保持できず、
            そもそも何個か前のプロンプトの内容は参照されないということが起きていたのでしょう。最近はうまく近似を使って
            めちゃめちゃ長いコンテキストウィンドウを保持し、行列計算を工夫しているものだと思われます。
            余談ですが、最近のChat GPTは口調だったりも変えてくれますよね。あれはおそらくたとえば「ギャルっぽく」などと言った時に対応する
            空間(3次元ではないですが)が固まって存在していて(つまりギャルっぽいトークンベクトルは互いに近くにあって)、入力としてそのような指示があった際にはその部分が参照されるようになって
            確率分布が計算されることによりワードチョイスがしっかりギャルっぽくなるのだと思います。
        </p>
    </article>
  </main>
  
  <aside class="sidebar">
    <h3>カテゴリ</h3>
    <ul>
      <li><a href="/papers" class="active">論文記録</a></li>
      <li><a href="/ML">機械学習のお勉強</a></li>
      <li><a href="/programming">その他プログラミング / 情報科学</a></li>
      <li><a href="/biology">その他生物学関連</a></li>
    </ul>
  </aside>
</div>

<button class="mobile-menu-btn" onclick="toggleSidebar()">
  <span>☰</span>
</button>

<div class="sidebar-overlay" onclick="closeSidebar()"></div>
  
  <footer>
    <p>&copy; 2025 ブログを書いてモチベを上げよう. All rights reserved.</p>
  </footer>

  <script>
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.toggle('active');
  overlay.classList.toggle('active');
}

function closeSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.remove('active');
  overlay.classList.remove('active');
}
function copyCode(button) {
  const codeBlock = button.closest('.code-block');
  const codeContent = codeBlock.querySelector('.code-content code');
  const text = codeContent.textContent;
  
  navigator.clipboard.writeText(text).then(() => {
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('コピーに失敗しました:', err);
    // フォールバック: 古いブラウザ対応
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  });
}
</script>
</body>
</html>
