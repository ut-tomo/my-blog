<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="3iZ0PCFwbOdy1LWlHA3A9nYmzBIZp8Qv12Dw2jHYOEU" />
  <title>This is all you need to understand "Attention Is All You Need"(多分) 準備 - ブログを書いてモチベを上げよう</title>
  <link rel="stylesheet" href="/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
</head>
<body>
  <header>
    <h1>ブログを書いてモチベを上げよう</h1>
  </header>
  
  <div class="page-layout">
  <main class="main-content">
    <div class="breadcrumb">
      <a href="/">ホーム</a> > <a href="/papers">論文</a> > This is all you need to understand "Attention Is All You Need"(多分)本番
    </div>
    
    <article>
      <h1>This is all you need to understand "Attention Is All You Need"(多分) 本番</h1>
      <p> 2025年6月19日</p>
      
      <h2>概要</h2>
      <p>
        この記事では、タイトルの通りTransformerモデルのオリジナルの論文である"Attention Is All You Need"を
        この記事で完結できるような形で噛み砕いでいくことを目指しますという趣旨で前回の準備記事に引き続き、
        論文を実際に頭から読んでいく形で書き下していこうかと思います。
      </p>
      <p>
        "Attention Is All You Need" : <a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a>
      </p>
      <p>前回の記事: <a href="./transformer1.html">This is all you need to understand "Attention Is All You Need"(多分)準備</a></p>
      
      <h2>
        イントロ / 背景など
      </h2>
      <p>
        AbstractやIntroduction, Backgroundあたりでは、このTransformerというモデルが
        Encode-Decoderモデルであるというちょっとしたネタバレとともに、
        従来のRNNやCNNベースのモデルよりも機械翻訳タスクにおいて優れた結果を示しましたよということが述べられています。
        この機械翻訳タスクの評価はBLEUスコアという指標を用いて行われていて、簡単にいうと訳文と参照文の一致度を図る指標らしく、大きければ大きいほど
        いいらしいです。30くらいの値で、人が翻訳したのと区別がつきにくいくらいすごい、という感じなようです。<br>
        ちなみにこのタスクとしてメジャーどころは英語ドイツ語の翻訳と、英語フランス語の翻訳あたりっぽいですが、
        英語フランス語の翻訳タスクの方がBLEUスコアが比較的高く出やすい、つまりタスクとしては比較的簡単なようです。
        英語もドイツ語のゲルマン系の言語なのに、意外ですね。<br>
        しかしこの論文の導入部分で最も強調されているのはこのTransformerは翻訳タスクのスコアが高いんだぞというところにはないように読み取れます。
        真に強調されているのは、このTransformerモデルは学習にかかる時間が少ないのだというところでしょう。
        Transformer以前は機械翻訳といえばLSTM(RNNの一種)で実装されている、というような時代だったらしいのですがその構造上シーケンシャルにしか計算できない、つまり
        並列化ができないという欠点を(結構直接的に)ディスっているような入りです。
      </p>
    </article>
  </main>
  
  <aside class="sidebar">
    <h3>カテゴリ</h3>
    <ul>
      <li><a href="/papers" class="active">論文記録</a></li>
      <li><a href="/ml">機械学習のお勉強</a></li>
      <li><a href="/programming">その他プログラミング / 情報科学</a></li>
      <li><a href="/biology">その他生物学関連</a></li>
    </ul>
  </aside>
</div>

<button class="mobile-menu-btn" onclick="toggleSidebar()">
  <span>☰</span>
</button>

<div class="sidebar-overlay" onclick="closeSidebar()"></div>
  
  <footer>
    <p>&copy; 2025 ブログを書いてモチベを上げよう. All rights reserved.</p>
  </footer>

  <script>
function toggleSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.toggle('active');
  overlay.classList.toggle('active');
}

function closeSidebar() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.sidebar-overlay');
  
  sidebar.classList.remove('active');
  overlay.classList.remove('active');
}
function copyCode(button) {
  const codeBlock = button.closest('.code-block');
  const codeContent = codeBlock.querySelector('.code-content code');
  const text = codeContent.textContent;
  
  navigator.clipboard.writeText(text).then(() => {
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('コピーに失敗しました:', err);
    // フォールバック: 古いブラウザ対応
    const textArea = document.createElement('textarea');
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    const originalText = button.textContent;
    button.textContent = 'Copied!';
    button.classList.add('copied');
    
    setTimeout(() => {
      button.textContent = originalText;
      button.classList.remove('copied');
    }, 2000);
  });
}
</script>
</body>
</html>
